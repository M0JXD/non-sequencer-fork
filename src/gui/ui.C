//
// Copyright (C) 2008 Jonathan Moore Liles
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//

// generated by Fast Light User Interface Designer (fluid) version 1.0300

#include "ui.H"
#include <About_Dialog.H>
#include <FL/Fl_Theme_Chooser.H>
#include <Fl_Scalepack.H>
#include <Fl_Sometimes_Input.H>
#include <Fl_Menu_Settings.H>
#include <FL/Fl_Shared_Image.H>
#include <math.h>
#include "event_edit.H"
#include "../jack.H"
#include "../NSM.H"
extern NSM_Client *nsm;
#include "../transport.H"
extern UI *ui;
class O_Canvas;
class Instrument_Editor;
Fl_Color canvas_background_color; 
Fl_Color velocity_colors[128]; 

static void init_colors() {
  unsigned int i;
      /* velocity colors */
  
      Fl_Color lo = fl_color_average( FL_CYAN, FL_BLACK, 0.10 );
      Fl_Color hi = fl_color_average( FL_CYAN, FL_WHITE, 0.80 );
  
      for ( i = 128; i--; )
      {
          velocity_colors[i] = fl_color_average( hi, lo, 1.0 * ((float)i / 128) );
      }
}
Visual_Metronome::Visual_Metronome(int X, int Y, int W, int H, const char *L)
  : Fl_Group(X, Y, W, H, L) {
{ Fl_Slider* o = progress = new Fl_Slider(139, 115, 1149, 23);
  progress->type(1);
  progress->box(FL_FLAT_BOX);
  progress->color(FL_BACKGROUND2_COLOR);
  progress->selection_color(FL_LIGHT3);
  o->resize( x(), (y() + h()) - (h() / 3), w(), h() / 3 );
  o->slider_size( 0.25 );
  o->slider( FL_FLAT_BOX  );
} // Fl_Slider* progress
_bpb = 0;
_tpb = 0;
_beat = 0;
_tick = 0;
_flip = 0;
end();
}

void Visual_Metronome::draw(void) {
  if ( damage() & ~FL_DAMAGE_CHILD )
  {
  	if ( ! _bpb )
  		return;
  
  int bw = w() / _bpb;
  
  int b = _bpb;
  
  if ( b )
  {
  
  for ( int i = 0; i < b; ++i )
  {
  		if ( i == _beat )
  		fl_color( velocity_colors[ i * 127 / _bpb ] );
  	else
  		fl_color( FL_GRAY );
  		
  	int X = x() + ( i * bw );
  	int Y = y();
  	int W = bw;
  	int H = h() - 14;
  	
  	fl_rectf(X,Y,W,H);
  	fl_color( fl_darker( fl_color() ) );
  	fl_rect( X,Y,W,H);
  		
  	char pat[4];
  		
  	snprintf( pat, sizeof(pat), "%d", i + 1 );
  	fl_font( FL_HELVETICA_BOLD, 24 );
  	fl_draw( pat, X,Y,W,H, FL_ALIGN_CENTER );
  	
  }
  }
  }
  progress->resize( x(), y() + h() - 14, w(), 14 );
  
  if ( damage() & FL_DAMAGE_CHILD )
  	update_child( *progress );
  else
  	draw_child( *progress );
  
  // _flip = ! _flip;
}

void Visual_Metronome::bpb( int b ) {
  if ( b != _bpb )
  {
  	_bpb = b;
  	redraw();
  }
}

void Visual_Metronome::tpb( int ticks ) {
  _tpb = ticks;
  
  progress->minimum( 0 );
  progress->maximum( ticks );
}

void Visual_Metronome::beat( int b ) {
  if ( b == _beat || b >= _bpb )
  	return;
  
  _flip = ! _flip;
  
  _beat = b;
  redraw();
}

void Visual_Metronome::tick( int tick ) {
  if ( tick == _tick )
  	return;
  	
  if ( _beat < 0 )
  	return;
  
  if ( _flip )
  {
  	progress->value( _tpb - tick );
  }
  else
  {
  	progress->value( tick );
  }
  
  _tick = tick;
}

void Visual_Metronome::update( void ) {
  if ( transport.beats_per_bar ) {
  bpb( transport.beats_per_bar );
  tpb( transport.ticks_per_beat );
  beat( transport.beat - 1 );
  tick( transport.tick - 1 );}
}

Overlay_Callback_Window::Overlay_Callback_Window(int X, int Y, int W, int H, const char *L) : Fl_Overlay_Window(X,Y,W,H,L) {
  _draw_overlay_callback = 0;
  _draw_overlay_userdata = 0;
}

Overlay_Callback_Window::Overlay_Callback_Window(int W, int H, const char *L) : Fl_Overlay_Window(W,H,L) {
  _draw_overlay_callback = 0;
  _draw_overlay_userdata = 0;
}

void Overlay_Callback_Window::draw_overlay() {
  if ( _draw_overlay_callback )
    _draw_overlay_callback( _draw_overlay_userdata );
}

void Overlay_Callback_Window::draw_overlay_callback( void(*cb)(void*), void *v) {
  _draw_overlay_callback = cb;
  _draw_overlay_userdata = v;
}

void update_transport( void * ) {
  // transport_poll();
  
  handle_midi_input();
  
   ui->progress_group->do_callback();
  
   ui->vmetro_widget->update();	
  
   ui->triggers_widget->update();
  
  Fl::repeat_timeout( TRANSPORT_POLL_INTERVAL, update_transport );
  
  static int oldstate = -1;
  
  if ( transport.rolling != oldstate )
  {
  
  	ui->play_button->label( transport.rolling ? "@square" : "@>" );
  	oldstate = transport.rolling;
  	
  	if ( transport.rolling )
  	{
  		ui->menu_new->deactivate();
  		ui->menu_open->deactivate();
  	}
  	else
  	{
  		ui->menu_new->activate();
  		ui->menu_open->activate();
  	}
  
  }
  
  if ( nsm && nsm->is_active() )
  {
       if ( ui->menu_new->active() )
       {
              ui->menu_new->deactivate();
              ui->menu_open->deactivate();
              ui->menu_save_as->deactivate(); 
       }
  }
  
  // JUST A TEST
  if ( transport.rolling )
  {
  	if ( ui->tabs->value() == ui->pattern_tab )
  		ui->pattern_canvas_widget->redraw_playhead();
  	else
  	if ( ui->tabs->value() == ui->phrase_tab )
  		ui->phrase_canvas_widget->redraw_playhead();
  
  }
  
  ui->transport_state->do_callback();
}

void UI::cb_main_window_i(Overlay_Callback_Window*, void*) {
  // Ignore escape
if ( Fl::event() == FL_SHORTCUT && Fl::event_key() == FL_Escape )
	return;
	 
if ( maybe_save_song() )
	quit();
}
void UI::cb_main_window(Overlay_Callback_Window* o, void* v) {
  ((UI*)(o->user_data()))->cb_main_window_i(o,v);
}

void UI::cb_BPM_i(Fl_Value_Input* o, void*) {
  transport.set_beats_per_minute( o->value() );
}
void UI::cb_BPM(Fl_Value_Input* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_BPM_i(o,v);
}

void UI::cb__i(Fl_Value_Input* o, void*) {
  transport.set_beats_per_bar( o->value() );
}
void UI::cb_(Fl_Value_Input* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb__i(o,v);
}

void UI::cb_1_i(Fl_Value_Input* o, void*) {
  transport.set_beat_type( o->value() );
}
void UI::cb_1(Fl_Value_Input* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_1_i(o,v);
}

void UI::cb_record_mode_menu_i(Fl_Choice* o, void*) {
  if ( ! transport.recording )
	config.record_mode = (record_mode_e)o->value();
else
	o->value( config.record_mode );
}
void UI::cb_record_mode_menu(Fl_Choice* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_record_mode_menu_i(o,v);
}

Fl_Menu_Item UI::menu_record_mode_menu[] = {
 {"Merge", 0,  0, 0, 0, FL_NORMAL_LABEL, 3, 10, 0},
 {"Overwrite", 0,  0, 0, 0, FL_NORMAL_LABEL, 3, 10, 0},
 {"Layer", 0,  0, 0, 0, FL_NORMAL_LABEL, 3, 10, 0},
 {"New", 0,  0, 0, 0, FL_NORMAL_LABEL, 3, 10, 0},
 {0,0,0,0,0,0,0,0,0}
};

void UI::cb_Pattern_i(Fl_Menu_*, void*) {
  song.play_mode = PATTERN;
}
void UI::cb_Pattern(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_Pattern_i(o,v);
}

void UI::cb_Sequence_i(Fl_Menu_*, void*) {
  song.play_mode = SEQUENCE;
}
void UI::cb_Sequence(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_Sequence_i(o,v);
}

void UI::cb_Trigger_i(Fl_Menu_*, void*) {
  song.play_mode = TRIGGER;
}
void UI::cb_Trigger(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_Trigger_i(o,v);
}

void UI::cb_Queue_i(Fl_Menu_*, void*) {
  song.play_mode = QUEUE;
}
void UI::cb_Queue(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_Queue_i(o,v);
}

Fl_Menu_Item UI::menu_playback_mode_menu[] = {
 {"Pattern", 0,  (Fl_Callback*)UI::cb_Pattern, 0, 0, FL_NORMAL_LABEL, 3, 10, 0},
 {"Sequence", 0,  (Fl_Callback*)UI::cb_Sequence, 0, 0, FL_NORMAL_LABEL, 3, 10, 0},
 {"Trigger", 0,  (Fl_Callback*)UI::cb_Trigger, 0, 0, FL_NORMAL_LABEL, 3, 10, 0},
 {"Queue", 0,  (Fl_Callback*)UI::cb_Queue, 0, 0, FL_NORMAL_LABEL, 3, 10, 0},
 {0,0,0,0,0,0,0,0,0}
};

void UI::cb_Sequence1_i(Fl_Button*, void*) {
  tabs->value( sequence_tab );


edit_menu->deactivate();
menu_bar->redraw();
}
void UI::cb_Sequence1(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Sequence1_i(o,v);
}

void UI::cb_Phrase_i(Fl_Button*, void*) {
  tabs->value( phrase_tab );

edit_menu->activate();
menu_bar->redraw();
}
void UI::cb_Phrase(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Phrase_i(o,v);
}

void UI::cb_Pattern1_i(Fl_Button*, void*) {
  tabs->value( pattern_tab );

edit_menu->activate();
menu_bar->redraw();
}
void UI::cb_Pattern1(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_Pattern1_i(o,v);
}

void UI::cb_play_button_i(Fl_Button*, void*) {
  transport.toggle();
}
void UI::cb_play_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_play_button_i(o,v);
}

void UI::cb_rec_button_i(Fl_Button* o, void*) {
  transport.recording = o->value();


if ( o->value() )
{
	if ( config.record_mode == NEW )
	{
		pattern *p = new pattern;
		p->length( -1 );
		
		pattern_canvas_widget->grid( p );
	}
	
	((pattern*)pattern_canvas_widget->grid())->record( 0 );
	
	o->labelcolor( FL_RED );
}
else
{
	pattern::recording()->record_stop();
	
	o->labelcolor( FL_WHITE );
};
}
void UI::cb_rec_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_rec_button_i(o,v);
}

void UI::cb_home_button_i(Fl_Button*, void*) {
  transport.locate( 0 );
}
void UI::cb_home_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_home_button_i(o,v);
}

void UI::cb_tabs_i(Fl_Tabs* o, void*) {
  ((Fl_Group*)o->value())->child( 0 )->take_focus();
}
void UI::cb_tabs(Fl_Tabs* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_tabs_i(o,v);
}

void UI::cb_sequence_phrase_delete_button_i(Fl_Button*, void*) {
  int val = playlist_browser->value();

if ( val > 1 )
{
//	playlist_browser->value( playlist_browser->value() + 1 );

	playlist->remove( val - 2 );

	update_sequence_widgets();
	
	if ( ! playlist_browser->value() )
		playlist_browser->value( playlist_browser->size() );
};
}
void UI::cb_sequence_phrase_delete_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_sequence_phrase_delete_button_i(o,v);
}

void UI::cb_sequence_phrase_up_button_i(Fl_Button*, void*) {
  if ( playlist_browser->value() > 2 )
{
	playlist->move( playlist_browser->value() - 2, UP );
	playlist_browser->value( playlist_browser->value() - 1 );
	update_sequence_widgets();
};
}
void UI::cb_sequence_phrase_up_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_sequence_phrase_up_button_i(o,v);
}

void UI::cb_sequence_phrase_down_button_i(Fl_Button*, void*) {
  if ( playlist_browser->value() > 1 )
{
	playlist->move( playlist_browser->value() - 2, DOWN );
	playlist_browser->value( playlist_browser->value() + 1 );
	update_sequence_widgets();
};
}
void UI::cb_sequence_phrase_down_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_sequence_phrase_down_button_i(o,v);
}

void UI::cb_sequence_phrase_choice_i(Fl_Menu_Button* o, void*) {
  playlist->insert( playlist_browser->value() - 1, o->value() + 1 );

update_sequence_widgets();

int val = playlist_browser->value();

if ( val )
	playlist_browser->value( playlist_browser->value() + 1 );
else
	playlist_browser->value( playlist_browser->size() );
}
void UI::cb_sequence_phrase_choice(Fl_Menu_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_sequence_phrase_choice_i(o,v);
}

void UI::cb_sequence_name_field_i(Fl_Input* o, void*) {
  playlist->name( o->value() );
}
void UI::cb_sequence_name_field(Fl_Input* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_sequence_name_field_i(o,v);
}

void UI::cb_detach_button_i(Fl_Light_Button* o, void*) {
  if ( o->value() )
{
	Fl_Group *g = seq_detached_group;
	seq_window->show();
	g->add( sequence_tab );
	sequence_tab->resize( g->x(), g->y(), g->w(), g->h() );
	tabs->do_callback();
	main_window->redraw();
}
else
{
	seq_window->hide();
	tabs->insert( (Fl_Widget&)*sequence_tab, 0 );
	sequence_tab->resize( pattern_tab->x(), pattern_tab->y(), pattern_tab->w(), pattern_tab->h() );
	tabs->do_callback();	
};
}
void UI::cb_detach_button(Fl_Light_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_detach_button_i(o,v);
}

void UI::cb_sequence_notes_edit_i(Fl_Text_Editor* o, void*) {
  playlist->notes( o->buffer()->text() );
}
void UI::cb_sequence_notes_edit(Fl_Text_Editor* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_sequence_notes_edit_i(o,v);
}

void UI::cb_progress_group_i(Fl_Group* o, void*) {
  if ( ! o->visible_r() )
	return;

phrase *p = phrase::phrase_by_number( playlist->playing() );

if ( p )
	phrase_progress->value( p->index() / (double)p->length() );
	
if ( playlist->length() )
	sequence_progress->value( playlist->index() / (double)playlist->length() );
}
void UI::cb_progress_group(Fl_Group* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_progress_group_i(o,v);
}

void UI::cb_sequence_progress_i(Fl_Slider* o, void*) {
  transport.locate( (tick_t)((double)playlist->length() * o->value()) );
}
void UI::cb_sequence_progress(Fl_Slider* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_sequence_progress_i(o,v);
}

void UI::cb_phrase_name_field_i(Fl_Sometimes_Input* o, void*) {
  phrase_canvas_widget->grid()->name( strdup( o->value() ) );

// if the name changed..
update_sequence_widgets();
}
void UI::cb_phrase_name_field(Fl_Sometimes_Input* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_phrase_name_field_i(o,v);
}

void UI::cb_phrase_notes_edit_i(Fl_Text_Editor* o, void*) {
  phrase_canvas_widget->grid()->notes( o->buffer()->text() );
}
void UI::cb_phrase_notes_edit(Fl_Text_Editor* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_phrase_notes_edit_i(o,v);
}

void UI::cb_phrase_number_spinner_i(Fl_Value_Slider* o, void*) {
  phrase *p = ((phrase *)phrase_canvas_widget->grid())->by_number( o->value() );

if ( p )
    phrase_canvas_widget->grid( p );

o->maximum( phrase::phrases() );
}
void UI::cb_phrase_number_spinner(Fl_Value_Slider* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->user_data()))->cb_phrase_number_spinner_i(o,v);
}

void UI::cb_pattern_name_field_i(Fl_Sometimes_Input* o, void*) {
  pattern_canvas_widget->grid()->name( strdup( o->value() ) );
}
void UI::cb_pattern_name_field(Fl_Sometimes_Input* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_pattern_name_field_i(o,v);
}

void UI::cb_pattern_mute_button_i(Fl_Light_Button* o, void*) {
  Grid *g = pattern_canvas_widget->grid();

g->mode( g->mode() == MUTE ? PLAY : MUTE );

o->value( g->mode() == MUTE );

pattern_solo_button->value( 0 );
}
void UI::cb_pattern_mute_button(Fl_Light_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_pattern_mute_button_i(o,v);
}

void UI::cb_pattern_solo_button_i(Fl_Light_Button* o, void*) {
  Grid *g = pattern_canvas_widget->grid();

g->mode( g->mode() == SOLO ? PLAY : SOLO );

o->value( g->mode() == SOLO );

pattern_mute_button->value( 0 );
}
void UI::cb_pattern_solo_button(Fl_Light_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_pattern_solo_button_i(o,v);
}

void UI::cb_pattern_number_spinner_i(Fl_Value_Slider* o, void*) {
  pattern *p = ((pattern *)pattern_canvas_widget->grid())->by_number( o->value() );

if ( p )
    pattern_canvas_widget->grid( p );

o->maximum( pattern::patterns() );
}
void UI::cb_pattern_number_spinner(Fl_Value_Slider* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_pattern_number_spinner_i(o,v);
}

void UI::cb_pattern_selection_mode_i(Fl_Button* o, void*) {
  pattern_canvas_widget->selection_mode( o->value() );
}
void UI::cb_pattern_selection_mode(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_pattern_selection_mode_i(o,v);
}

void UI::cb_velocity_slider_i(Fl_Value_Slider* o, void*) {
  pattern_canvas_widget->selected_velocity( o->value() );
}
void UI::cb_velocity_slider(Fl_Value_Slider* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_velocity_slider_i(o,v);
}

void UI::cb_mapping_menu_i(Fl_Menu_Button* o, void*) {
  mapping_text->value( o->text() );


char picked[80];
mapping_menu->item_pathname(picked, sizeof(picked)-1 );

if ( 0 == strncmp( picked, "Instrument", strlen( "Instrument" ) ) )
{
	((pattern*)pattern_canvas_widget->grid())->mapping.open( Mapping::INSTRUMENT, o->text() );

	pattern_canvas_widget->changed_mapping();

	pattern_key_combo->deactivate();
}
else
if ( 0 == strncmp( picked, "Scale", strlen( "Scale" ) ) )
{
	((pattern*)pattern_canvas_widget->grid())->mapping.open( Mapping::SCALE, o->text() );

	pattern_canvas_widget->changed_mapping();

	pattern_key_combo->activate();
};
}
void UI::cb_mapping_menu(Fl_Menu_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_mapping_menu_i(o,v);
}

Fl_Menu_Item UI::menu_mapping_menu[] = {
 {"Scale", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Instrument", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};
Fl_Menu_Item* UI::mapping_scale_menu = UI::menu_mapping_menu + 0;
Fl_Menu_Item* UI::mapping_instrument_menu = UI::menu_mapping_menu + 2;

void UI::cb_pattern_key_combo_i(Fl_Choice* o, void*) {
  ((pattern*)pattern_canvas_widget->grid())->mapping.key( o->value() );

pattern_canvas_widget->changed_mapping();
}
void UI::cb_pattern_key_combo(Fl_Choice* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_pattern_key_combo_i(o,v);
}

Fl_Menu_Item UI::menu_pattern_key_combo[] = {
 {"C", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"C#/Db", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"D", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"D#/Eb", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"E", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"F", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"F#/Gb", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"G", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"G#", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"A", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"A#/Bb", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"B", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {0,0,0,0,0,0,0,0,0}
};

void UI::cb_pattern_note_combo_i(Fl_Choice* o, void*) {
  ((pattern*)pattern_canvas_widget->grid())->note( atoi( o->menu()[ o->value() ].text ));
}
void UI::cb_pattern_note_combo(Fl_Choice* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_pattern_note_combo_i(o,v);
}

Fl_Menu_Item UI::menu_pattern_note_combo[] = {
 {"1", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"2", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"4", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"8", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"16", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"32", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"64", 0,  0, 0, 128, FL_NORMAL_LABEL, 0, 11, 0},
 {"3", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"6", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"12", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"24", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {0,0,0,0,0,0,0,0,0}
};

void UI::cb_pattern_res_combo_i(Fl_Choice* o, void*) {
  pattern_canvas_widget->grid()->resolution( atoi( o->menu()[ o->value() ].text ));
}
void UI::cb_pattern_res_combo(Fl_Choice* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_pattern_res_combo_i(o,v);
}

Fl_Menu_Item UI::menu_pattern_res_combo[] = {
 {"1", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"2", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"4", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"8", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"16", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"32", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"64", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"128", 0,  0, 0, 128, FL_NORMAL_LABEL, 0, 11, 0},
 {"3", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"6", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"12", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {"24", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 11, 0},
 {0,0,0,0,0,0,0,0,0}
};

void UI::cb_pattern_channel_choice_i(Fl_Choice* o, void*) {
  ((pattern *)pattern_canvas_widget->grid())->channel( o->value() );
}
void UI::cb_pattern_channel_choice(Fl_Choice* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_pattern_channel_choice_i(o,v);
}

void UI::cb_pattern_port_choice_i(Fl_Choice* o, void*) {
  ((pattern *)pattern_canvas_widget->grid())->port( o->value() );
}
void UI::cb_pattern_port_choice(Fl_Choice* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_pattern_port_choice_i(o,v);
}

void UI::cb_pattern_bars_choice_i(Fl_Input_Choice* o, void*) {
  ((pattern *)pattern_canvas_widget->grid())->bars( atoi( o->value() ) );
}
void UI::cb_pattern_bars_choice(Fl_Input_Choice* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_pattern_bars_choice_i(o,v);
}

void UI::cb_transport_state_i(Fl_Box* o, void*) {
  const char *s = "INVALID";

if ( transport.master )
	s = "Master";
else if ( transport.valid )
	s = "Slave";

if ( s != o->label() )
{
	o->label( s );
	if ( ! strcmp( s, "INVALID" ) )
		o->color( fl_darker( FL_RED ) );
	else
		o->color( FL_BACKGROUND_COLOR );
};
}
void UI::cb_transport_state(Fl_Box* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_transport_state_i(o,v);
}

void UI::cb_menu_new_i(Fl_Menu_*, void*) {
  if ( maybe_save_song() )
{
	init_song();

	// Sync the GUI.
	update_pattern_widgets();
	update_sequence_widgets();
	update_phrase_widgets();
	
	
	gui_status( "New song." );
};
}
void UI::cb_menu_new(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_menu_new_i(o,v);
}

void UI::cb_menu_open_i(Fl_Menu_*, void*) {
  char *name = fl_file_chooser( "Open File", "Non Files (*.non)", NULL, 0 );

if ( name )
{
	if ( ! load_song( name ) )
		fl_alert( "Could not load song!" );
	else
		gui_status( "Song opened." );
	
	update_sequence_widgets();
	update_pattern_widgets();
	update_phrase_widgets();

	playback_mode_menu->value( song.play_mode );
	playback_mode_menu->redraw();
};
}
void UI::cb_menu_open(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_menu_open_i(o,v);
}

void UI::cb_menu_save_i(Fl_Menu_*, void*) {
  save_dialog( song.filename );
}
void UI::cb_menu_save(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_menu_save_i(o,v);
}

void UI::cb_menu_save_as_i(Fl_Menu_*, void*) {
  save_dialog( NULL );
}
void UI::cb_menu_save_as(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_menu_save_as_i(o,v);
}

void UI::cb_Import_i(Fl_Menu_*, void*) {
  char *name = fl_file_chooser( "MIDI Import", "MIDI Files (*.mid)", NULL, 0 );

if ( ! name )
	return;

smf f;

if ( ! f.open( name, smf::READ ) )
{
	fl_message( "could not open file" );
	return;
}

f.read_header();

switch ( f.format() )
{
	case 0:
		if ( ! pattern::import( &f, 0 ) )
			fl_message( "Error importing MIDI" );
		break;
	case 1: case 2:
		{
			char **sa = f.track_listing();

			if ( sa && *sa )
			{
				List_Chooser tc( "Select tracks to import:", "Import" );

			 	char *s;
				for ( int i = 0; (s = sa[i]); ++i )
				{
					tc.add( s );
					free( s );
				}

				free( sa );

				tc.show();

				while( tc.shown() )
					Fl::wait();

				int n = 0;
				for ( int i = 1; i <= tc.browser->size(); ++i )
				{
					if ( tc.browser->selected( i ) )
					{
						if ( pattern::import( &f , i - 1 ) )
							++n;
						else
							WARNING( "error importing track %d", i - 1 );
					}

				}
				// fl_message( "%d patterns imported.", n );
				gui_status( "Imported %d tracks as patterns", n );
			}

			break;
		}
};
}
void UI::cb_Import(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Import_i(o,v);
}

void UI::cb_Export_i(Fl_Menu_*, void*) {
  // Fl_File_Chooser::custom_filter_label = "*.mid";

Fl_File_Chooser *fc = new Fl_File_Chooser( ".", "MIDI Files (*.mid)", Fl_File_Chooser::CREATE, "MIDI Export" );

fc->show();

// wait for user to make a choice
while( fc->shown() )
      Fl::wait();

if ( ! fc->value() )
	return;

if ( tabs->value() == pattern_tab )
	((pattern*)pattern_canvas_widget->grid())->save( fc->value() );
}
void UI::cb_Export(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Export_i(o,v);
}

void UI::cb_Quit_i(Fl_Menu_*, void*) {
  main_window->do_callback();
}
void UI::cb_Quit(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Quit_i(o,v);
}

void UI::cb_Metronome_i(Fl_Menu_* o, void*) {
  int val = o->menu()[ o->value() ].value();

if ( val )
	vmetro_widget->show();
else
	vmetro_widget->hide();
}
void UI::cb_Metronome(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Metronome_i(o,v);
}

void UI::cb_Compacted_i(Fl_Menu_* o, void*) {
  int val = o->menu()[ o->value() ].value();

pattern_canvas_widget->row_compact( val ? Canvas::ON : Canvas::OFF );

pattern_canvas_widget->redraw();
}
void UI::cb_Compacted(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Compacted_i(o,v);
}

void UI::cb_Follow_i(Fl_Menu_* o, void*) {
  int val = o->menu()[ o->value() ].value();

config.follow_playhead = val ? true : false;
}
void UI::cb_Follow(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Follow_i(o,v);
}

void UI::cb_Theme_i(Fl_Menu_*, void*) {
  fl_theme_chooser();
}
void UI::cb_Theme(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Theme_i(o,v);
}

void UI::cb_Manual_i(Fl_Menu_*, void*) {
  show_help_dialog( "MANUAL" );
}
void UI::cb_Manual(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Manual_i(o,v);
}

void UI::cb_About_i(Fl_Menu_*, void*) {
  About_Dialog ab( PIXMAP_PATH "/non-sequencer/icon-256x256.png" );

            ab.logo_box->label( VERSION );

        ab.title->label( "Non Sequencer" );

        ab.copyright->label( "Copyright (C) 2007-2013 Jonathan Moore Liles" );
        ab.credits->label( "Non Sequencer was written from scratch by\nJonathan Moore Liles for his own use\n(see the manual).\n\nNobody planned. Nobody helped.\nYou can help now by donating time, money,\nand/or replacing the rest of Linux Audio\nwith fast, light, reliable alternatives.\n" );

        ab.website_url->label( "http://non.tuxfamily.org" );

ab.run();
}
void UI::cb_About(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_About_i(o,v);
}

void UI::cb_Add_i(Fl_Menu_*, void*) {
  Grid *g = current_canvas()->grid()->create();

current_canvas()->grid( g );

update_pattern_widgets();
update_sequence_widgets();
update_phrase_widgets();
}
void UI::cb_Add(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Add_i(o,v);
}

void UI::cb_Previous_i(Fl_Menu_*, void*) {
  if ( tabs->value() == pattern_tab )
{
	pattern_number_spinner->value( max( 0, (int)pattern_number_spinner->value() - 1 ) );
	pattern_number_spinner->do_callback();
}
else
{
	phrase_number_spinner->value( max( 0, (int)phrase_number_spinner->value() - 1 ) );
	phrase_number_spinner->do_callback();
};
}
void UI::cb_Previous(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Previous_i(o,v);
}

void UI::cb_Next_i(Fl_Menu_*, void*) {
  if ( tabs->value() == pattern_tab )
{
	pattern_number_spinner->value( min( 127, (int)pattern_number_spinner->value() + 1 ));
	pattern_number_spinner->do_callback();
}
else
{
	phrase_number_spinner->value( min( 127, (int)phrase_number_spinner->value() + 1 ));
	phrase_number_spinner->do_callback();
};
}
void UI::cb_Next(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Next_i(o,v);
}

void UI::cb_Duplicate_i(Fl_Menu_*, void*) {
  Canvas *w = current_canvas();

w->grid( w->grid()->clone() );

// number of phrases may have changed.
ui->update_sequence_widgets();
}
void UI::cb_Duplicate(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Duplicate_i(o,v);
}

void UI::cb_Delete_i(Fl_Menu_*, void*) {
  Canvas *w = current_canvas();

w->grid()->delete_selected();
}
void UI::cb_Delete(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Delete_i(o,v);
}

void UI::cb_Clear_i(Fl_Menu_*, void*) {
  Canvas *w = current_canvas();

w->grid()->clear();
}
void UI::cb_Clear(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Clear_i(o,v);
}

void UI::cb_Edit_i(Fl_Menu_*, void*) {
  event_editor( pattern_canvas_widget->grid() );
}
void UI::cb_Edit(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Edit_i(o,v);
}

void UI::cb_Select_i(Fl_Menu_*, void*) {
  Canvas *w = current_canvas();

w->grid()->select_all();
}
void UI::cb_Select(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Select_i(o,v);
}

void UI::cb_Select1_i(Fl_Menu_*, void*) {
  Canvas *w = current_canvas();

w->grid()->select_none();
}
void UI::cb_Select1(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Select1_i(o,v);
}

void UI::cb_Invert_i(Fl_Menu_*, void*) {
  Canvas *w = current_canvas();

w->grid()->invert_selection();
}
void UI::cb_Invert(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Invert_i(o,v);
}

void UI::cb_Cut_i(Fl_Menu_*, void*) {
  Canvas *w = current_canvas();

w->cut();
}
void UI::cb_Cut(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Cut_i(o,v);
}

void UI::cb_Copy_i(Fl_Menu_*, void*) {
  Canvas *w = current_canvas();

w->copy();
}
void UI::cb_Copy(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Copy_i(o,v);
}

void UI::cb_Paste_i(Fl_Menu_*, void*) {
  Canvas *w = current_canvas();

w->paste();
}
void UI::cb_Paste(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Paste_i(o,v);
}

void UI::cb_Undo_i(Fl_Menu_*, void*) {
  Canvas *w = current_canvas();

w->grid()->undo();
}
void UI::cb_Undo(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Undo_i(o,v);
}

Fl_Menu_Item UI::menu_menu_bar[] = {
 {"&File", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"&New", 0,  (Fl_Callback*)UI::cb_menu_new, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Open", 0x4006f,  (Fl_Callback*)UI::cb_menu_open, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Save", 0x40073,  (Fl_Callback*)UI::cb_menu_save, 0, 1, FL_NORMAL_LABEL, 0, 14, 0},
 {"Save &As", 0,  (Fl_Callback*)UI::cb_menu_save_as, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Import", 0,  (Fl_Callback*)UI::cb_Import, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Export", 0,  (Fl_Callback*)UI::cb_Export, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Quit", 0x40071,  (Fl_Callback*)UI::cb_Quit, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&View", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Metronome", 0,  (Fl_Callback*)UI::cb_Metronome, 0, 6, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Compacted", 0,  (Fl_Callback*)UI::cb_Compacted, 0, 6, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Follow Playhead", 0,  (Fl_Callback*)UI::cb_Follow, 0, 6, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Theme", 0,  (Fl_Callback*)UI::cb_Theme, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Help", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Manual", 0,  (Fl_Callback*)UI::cb_Manual, 0, 128, FL_NORMAL_LABEL, 0, 14, 0},
 {"&About", 0,  (Fl_Callback*)UI::cb_About, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Edit", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Add New", 0x61,  (Fl_Callback*)UI::cb_Add, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Previous", 0x5b,  (Fl_Callback*)UI::cb_Previous, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Next", 0x5d,  (Fl_Callback*)UI::cb_Next, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Duplicate", 0x64,  (Fl_Callback*)UI::cb_Duplicate, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Delete Selected", 0xffff,  (Fl_Callback*)UI::cb_Delete, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Clear", 0x1ffff,  (Fl_Callback*)UI::cb_Clear, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Edit Events", 0,  (Fl_Callback*)UI::cb_Edit, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Select All", 0x40061,  (Fl_Callback*)UI::cb_Select, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Select None", 0x50061,  (Fl_Callback*)UI::cb_Select1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Invert Selection", 0x50069,  (Fl_Callback*)UI::cb_Invert, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Cut", 0x40078,  (Fl_Callback*)UI::cb_Cut, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Copy", 0x40063,  (Fl_Callback*)UI::cb_Copy, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Paste", 0x40076,  (Fl_Callback*)UI::cb_Paste, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Undo", 0x4007a,  (Fl_Callback*)UI::cb_Undo, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};
Fl_Menu_Item* UI::menu_new = UI::menu_menu_bar + 1;
Fl_Menu_Item* UI::menu_open = UI::menu_menu_bar + 2;
Fl_Menu_Item* UI::menu_save = UI::menu_menu_bar + 3;
Fl_Menu_Item* UI::menu_save_as = UI::menu_menu_bar + 4;
Fl_Menu_Item* UI::edit_menu = UI::menu_menu_bar + 19;

void UI::cb_seq_window_i(Fl_Double_Window* o, void*) {
  sequence_tab->activate();
o->hide();
detach_button->value( 0 );
}
void UI::cb_seq_window(Fl_Double_Window* o, void* v) {
  ((UI*)(o->user_data()))->cb_seq_window_i(o,v);
}

UI::UI() {
  fl_register_images();
  
  canvas_background_color = FL_GREEN;
  
  playback_mode_menu = NULL;
  
  main_window = make_main_window();
  seq_window = make_seq_window();
  
  init_colors();
  
  // make_instrument_edit_dialog();
  
  // use old focus behavior
  Fl::visible_focus( 0 );
  
  // try to fill the screen, but only when the screen is tiny and our window is huge.
  {
          int sx, sy, sw, sh;
  
          Fl::screen_xywh( sx, sy, sw, sh );
  
          if ( sw < main_window->w() || sh < main_window->h() )
              main_window->resize( sx, sy, sw, sh );
  }
  
  Fl::add_timeout( TRANSPORT_POLL_INTERVAL, update_transport );
  
  
  playlist->signal_new_song.connect( sigc::mem_fun( this, &UI::update_sequence_widgets ) );
  pattern_canvas_widget->signal_settings_change.connect( sigc::mem_fun( this, &UI::update_pattern_widgets ) );
  phrase_canvas_widget->signal_settings_change.connect( sigc::mem_fun( this, &UI::update_phrase_widgets ) );
}

UI::~UI() {
  delete seq_window;
  delete main_window;
}

void UI::run() {
  Fl::run();
}

void UI::load_settings() {
  char *path;
  
  asprintf( &path, "%s/%s", config.user_config_dir, "view" );
  
  ((Fl_Menu_Settings*)menu_bar)->load( menu_bar->find_item( "&View" ), path );
  
  free( path );
}

void UI::save_settings() {
  char *path;
  
  asprintf( &path, "%s/%s", config.user_config_dir, "view" );
  
  ((Fl_Menu_Settings*)menu_bar)->dump( menu_bar->find_item( "&View" ), path );
  
  free( path );
}

void UI::draw_overlay( void *v ) {
  ((UI*)v)->draw_overlay();
}

void UI::draw_overlay() {
  Canvas *c = current_canvas();
  if ( c )
     c->draw_overlay();
}

Overlay_Callback_Window* UI::make_main_window() {
  { Overlay_Callback_Window* o = main_window = new Overlay_Callback_Window(865, 805, "Non Sequencer");
    main_window->box(FL_FLAT_BOX);
    main_window->color(FL_DARK1);
    main_window->selection_color(FL_BACKGROUND_COLOR);
    main_window->labeltype(FL_NO_LABEL);
    main_window->labelfont(0);
    main_window->labelsize(14);
    main_window->labelcolor(FL_FOREGROUND_COLOR);
    main_window->callback((Fl_Callback*)cb_main_window, (void*)(this));
    main_window->align(Fl_Align(FL_ALIGN_TOP));
    main_window->when(FL_WHEN_RELEASE);
    { Fl_Group* o = new Fl_Group(0, 25, 865, 70);
      o->box(FL_FLAT_BOX);
      { Fl_Group* o = new Fl_Group(552, 26, 312, 69);
        { Fl_Value_Input* o = new Fl_Value_Input(825, 39, 35, 19, "BPM");
          o->labelsize(9);
          o->textsize(10);
          o->callback((Fl_Callback*)cb_BPM);
          o->align(Fl_Align(FL_ALIGN_TOP));
          o->when(FL_WHEN_ENTER_KEY);
          transport.signal_tempo_change.connect( sigc::mem_fun( o, static_cast<int (Fl_Valuator::*)(double)>(&Fl_Valuator::value) ) );
          o->value( transport.beats_per_minute );
        } // Fl_Value_Input* o
        { Fl_Group* o = new Fl_Group(756, 38, 64, 21, "Time Sig.");
          o->labelsize(9);
          { Fl_Value_Input* o = new Fl_Value_Input(756, 39, 24, 19);
            o->textsize(10);
            o->callback((Fl_Callback*)cb_);
            transport.signal_bpb_change.connect( sigc::mem_fun( o, static_cast<int (Fl_Valuator::*)(double)>(&Fl_Valuator::value) ) );
            o->value( transport.beats_per_bar );
          } // Fl_Value_Input* o
          { new Fl_Box(780, 38, 14, 21, "/");
          } // Fl_Box* o
          { Fl_Value_Input* o = new Fl_Value_Input(795, 39, 24, 19);
            o->textsize(10);
            o->callback((Fl_Callback*)cb_1);
            transport.signal_beat_change.connect( sigc::mem_fun( o, static_cast<int (Fl_Valuator::*)(double)>(&Fl_Valuator::value) ) );
            o->value( transport.beat_type );
          } // Fl_Value_Input* o
          o->end();
        } // Fl_Group* o
        { record_mode_menu = new Fl_Choice(555, 39, 105, 19, "Record Mode");
          record_mode_menu->box(FL_DOWN_BOX);
          record_mode_menu->down_box(FL_BORDER_BOX);
          record_mode_menu->color((Fl_Color)37);
          record_mode_menu->labelsize(9);
          record_mode_menu->textsize(9);
          record_mode_menu->callback((Fl_Callback*)cb_record_mode_menu);
          record_mode_menu->align(Fl_Align(FL_ALIGN_TOP));
          record_mode_menu->menu(menu_record_mode_menu);
        } // Fl_Choice* record_mode_menu
        { playback_mode_menu = new Fl_Choice(665, 39, 85, 19, "Playback &Mode");
          playback_mode_menu->box(FL_DOWN_BOX);
          playback_mode_menu->down_box(FL_BORDER_BOX);
          playback_mode_menu->color((Fl_Color)37);
          playback_mode_menu->labelsize(9);
          playback_mode_menu->align(Fl_Align(FL_ALIGN_TOP));
          playback_mode_menu->menu(menu_playback_mode_menu);
        } // Fl_Choice* playback_mode_menu
        { Fl_Scalepack* o = new Fl_Scalepack(555, 60, 305, 30);
          o->type(1);
          o->box(FL_NO_BOX);
          o->color(FL_BACKGROUND_COLOR);
          o->selection_color(FL_BACKGROUND_COLOR);
          o->labeltype(FL_NORMAL_LABEL);
          o->labelfont(0);
          o->labelsize(14);
          o->labelcolor(FL_FOREGROUND_COLOR);
          o->align(Fl_Align(FL_ALIGN_TOP));
          o->when(FL_WHEN_RELEASE);
          { Fl_Button* o = new Fl_Button(565, 70, 68, 15, "Sequence");
            o->type(102);
            o->shortcut(0x80031);
            o->selection_color((Fl_Color)69);
            o->callback((Fl_Callback*)cb_Sequence1);
          } // Fl_Button* o
          { Fl_Button* o = new Fl_Button(575, 80, 68, 5, "Phrase");
            o->type(102);
            o->shortcut(0x80032);
            o->selection_color((Fl_Color)69);
            o->callback((Fl_Callback*)cb_Phrase);
          } // Fl_Button* o
          { Fl_Button* o = new Fl_Button(585, 90, 68, 0, "Pattern");
            o->type(102);
            o->shortcut(0x80033);
            o->value(1);
            o->selection_color((Fl_Color)69);
            o->callback((Fl_Callback*)cb_Pattern1);
          } // Fl_Button* o
          o->end();
        } // Fl_Scalepack* o
        o->resizable(0);
        o->end();
      } // Fl_Group* o
      { Visual_Metronome* o = vmetro_widget = new Visual_Metronome(160, 27, 390, 61, "Metronome");
        vmetro_widget->type(1);
        vmetro_widget->box(FL_UP_BOX);
        vmetro_widget->color((Fl_Color)40);
        vmetro_widget->selection_color((Fl_Color)48);
        vmetro_widget->labeltype(FL_NORMAL_LABEL);
        vmetro_widget->labelfont(0);
        vmetro_widget->labelsize(33);
        vmetro_widget->labelcolor(FL_FOREGROUND_COLOR);
        vmetro_widget->align(Fl_Align(FL_ALIGN_CENTER));
        vmetro_widget->when(FL_WHEN_RELEASE);
        o->box( FL_FLAT_BOX );
        vmetro_widget->end();
        Fl_Group::current()->resizable(vmetro_widget);
      } // Visual_Metronome* vmetro_widget
      { Fl_Scalepack* o = transport_controls_group = new Fl_Scalepack(4, 27, 151, 60);
        transport_controls_group->type(1);
        transport_controls_group->box(FL_NO_BOX);
        transport_controls_group->color(FL_BACKGROUND_COLOR);
        transport_controls_group->selection_color(FL_BACKGROUND_COLOR);
        transport_controls_group->labeltype(FL_NORMAL_LABEL);
        transport_controls_group->labelfont(0);
        transport_controls_group->labelsize(14);
        transport_controls_group->labelcolor(FL_FOREGROUND_COLOR);
        transport_controls_group->align(Fl_Align(FL_ALIGN_TOP));
        transport_controls_group->when(FL_WHEN_RELEASE);
        { play_button = new Fl_Button(10, 29, 43, 38, "@>");
          play_button->shortcut(0x20);
          play_button->labeltype(FL_ENGRAVED_LABEL);
          play_button->callback((Fl_Callback*)cb_play_button);
        } // Fl_Button* play_button
        { rec_button = new Fl_Button(60, 29, 43, 38, "@circle");
          rec_button->type(1);
          rec_button->shortcut(0x80072);
          rec_button->selection_color(FL_DARK1);
          rec_button->labeltype(FL_ENGRAVED_LABEL);
          rec_button->callback((Fl_Callback*)cb_rec_button);
          rec_button->when(FL_WHEN_CHANGED);
        } // Fl_Button* rec_button
        { home_button = new Fl_Button(110, 29, 43, 38, "@|<");
          home_button->shortcut(0xff50);
          home_button->labeltype(FL_ENGRAVED_LABEL);
          home_button->callback((Fl_Callback*)cb_home_button);
        } // Fl_Button* home_button
        o->spacing( 2 );
        transport_controls_group->end();
      } // Fl_Scalepack* transport_controls_group
      o->end();
    } // Fl_Group* o
    { tabs = new Fl_Tabs(-1, 91, 868, 694);
      tabs->box(FL_FLAT_BOX);
      tabs->color(FL_DARK1);
      tabs->labeltype(FL_SHADOW_LABEL);
      tabs->labelsize(19);
      tabs->callback((Fl_Callback*)cb_tabs);
      tabs->when(FL_WHEN_CHANGED);
      { sequence_tab = new Fl_Group(0, 91, 865, 692);
        sequence_tab->box(FL_FLAT_BOX);
        sequence_tab->color((Fl_Color)37);
        sequence_tab->labeltype(FL_NO_LABEL);
        sequence_tab->labelsize(12);
        sequence_tab->hide();
        { Fl_Group* o = new Fl_Group(5, 118, 240, 502);
          o->labelsize(12);
          { Fl_Browser* o = playlist_browser = new Fl_Browser(5, 155, 240, 398, "Playlist");
            playlist_browser->type(2);
            playlist_browser->box(FL_EMBOSSED_BOX);
            playlist_browser->color(FL_DARK3);
            playlist_browser->selection_color((Fl_Color)30);
            playlist_browser->labelsize(12);
            playlist_browser->labelcolor((Fl_Color)55);
            playlist_browser->textsize(18);
            playlist_browser->textcolor(FL_YELLOW);
            playlist_browser->align(Fl_Align(FL_ALIGN_TOP));
            playlist_browser->when(FL_WHEN_RELEASE);
            Fl_Group::current()->resizable(playlist_browser);
            static int widths[] = { 40, 30, 0 };
            o->column_widths( widths ); o->column_char( '\t' );
            o->value( 1 );
          } // Fl_Browser* playlist_browser
          { sequence_phrase_delete_button = new Fl_Button(6, 559, 64, 25, "Delete");
            sequence_phrase_delete_button->shortcut(0xffff);
            sequence_phrase_delete_button->color(FL_RED);
            sequence_phrase_delete_button->labelcolor((Fl_Color)23);
            sequence_phrase_delete_button->callback((Fl_Callback*)cb_sequence_phrase_delete_button);
          } // Fl_Button* sequence_phrase_delete_button
          { sequence_phrase_up_button = new Fl_Button(135, 559, 45, 25, "Up");
            sequence_phrase_up_button->shortcut(0xffbf);
            sequence_phrase_up_button->callback((Fl_Callback*)cb_sequence_phrase_up_button);
          } // Fl_Button* sequence_phrase_up_button
          { sequence_phrase_down_button = new Fl_Button(185, 559, 58, 25, "Down");
            sequence_phrase_down_button->shortcut(0xffc0);
            sequence_phrase_down_button->callback((Fl_Callback*)cb_sequence_phrase_down_button);
          } // Fl_Button* sequence_phrase_down_button
          { sequence_phrase_choice = new Fl_Menu_Button(5, 590, 235, 30, "Insert Phrase");
            sequence_phrase_choice->color(FL_GREEN);
            sequence_phrase_choice->callback((Fl_Callback*)cb_sequence_phrase_choice);
          } // Fl_Menu_Button* sequence_phrase_choice
          o->end();
        } // Fl_Group* o
        { sequence_name_field = new Fl_Input(10, 109, 235, 27, "Name");
          sequence_name_field->color((Fl_Color)48);
          sequence_name_field->labelsize(12);
          sequence_name_field->callback((Fl_Callback*)cb_sequence_name_field);
          sequence_name_field->align(Fl_Align(FL_ALIGN_TOP));
          sequence_name_field->when(FL_WHEN_CHANGED);
        } // Fl_Input* sequence_name_field
        { detach_button = new Fl_Light_Button(7, 749, 78, 26, "Detach");
          detach_button->callback((Fl_Callback*)cb_detach_button);
        } // Fl_Light_Button* detach_button
        { Fl_Text_Editor* o = sequence_notes_edit = new Fl_Text_Editor(254, 732, 606, 48, "Notes:");
          sequence_notes_edit->selection_color((Fl_Color)48);
          sequence_notes_edit->labelsize(12);
          sequence_notes_edit->textcolor((Fl_Color)94);
          sequence_notes_edit->callback((Fl_Callback*)cb_sequence_notes_edit);
          sequence_notes_edit->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          o->buffer( sequence_notes_buffer = new Fl_Text_Buffer );
        } // Fl_Text_Editor* sequence_notes_edit
        { Triggers* o = triggers_widget = new Triggers(253, 118, 607, 598, "Patterns");
          triggers_widget->box(FL_FLAT_BOX);
          triggers_widget->color((Fl_Color)48);
          triggers_widget->selection_color(FL_BACKGROUND_COLOR);
          triggers_widget->labeltype(FL_NORMAL_LABEL);
          triggers_widget->labelfont(0);
          triggers_widget->labelsize(12);
          triggers_widget->labelcolor(FL_FOREGROUND_COLOR);
          triggers_widget->align(Fl_Align(FL_ALIGN_TOP));
          triggers_widget->when(FL_WHEN_RELEASE);
          Fl_Group::current()->resizable(triggers_widget);
          o->color( FL_BACKGROUND_COLOR );
          o->rows( 32 );
        } // Triggers* triggers_widget
        { progress_group = new Fl_Group(10, 649, 233, 66);
          progress_group->callback((Fl_Callback*)cb_progress_group);
          { phrase_progress = new Fl_Slider(10, 649, 233, 24, "Phrase");
            phrase_progress->type(1);
            phrase_progress->labelsize(12);
            phrase_progress->align(Fl_Align(FL_ALIGN_TOP));
          } // Fl_Slider* phrase_progress
          { sequence_progress = new Fl_Slider(10, 691, 233, 24, "Sequence");
            sequence_progress->type(1);
            sequence_progress->labelsize(12);
            sequence_progress->callback((Fl_Callback*)cb_sequence_progress);
            sequence_progress->align(Fl_Align(FL_ALIGN_TOP));
          } // Fl_Slider* sequence_progress
          progress_group->end();
        } // Fl_Group* progress_group
        update_sequence_widgets();
        sequence_tab->end();
        Fl_Group::current()->resizable(sequence_tab);
      } // Fl_Group* sequence_tab
      { phrase_tab = new Fl_Group(0, 91, 865, 693);
        phrase_tab->box(FL_FLAT_BOX);
        phrase_tab->color(FL_DARK1);
        phrase_tab->labeltype(FL_NO_LABEL);
        phrase_tab->hide();
        { phrase_canvas_widget = new Canvas(0, 91, 865, 637, "Phrase");
          phrase_canvas_widget->box(FL_FLAT_BOX);
          phrase_canvas_widget->color((Fl_Color)37);
          phrase_canvas_widget->selection_color(FL_BACKGROUND_COLOR);
          phrase_canvas_widget->labeltype(FL_NORMAL_LABEL);
          phrase_canvas_widget->labelfont(0);
          phrase_canvas_widget->labelsize(100);
          phrase_canvas_widget->labelcolor(FL_FOREGROUND_COLOR);
          phrase_canvas_widget->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
          phrase_canvas_widget->when(FL_WHEN_RELEASE);
          Fl_Group::current()->resizable(phrase_canvas_widget);
        } // Canvas* phrase_canvas_widget
        { phrase_settings_group = new Fl_Group(0, 728, 865, 55);
          phrase_settings_group->box(FL_FLAT_BOX);
          phrase_settings_group->color(FL_DARK1);
          { Fl_Sometimes_Input* o = phrase_name_field = new Fl_Sometimes_Input(5, 734, 185, 21, "name:");
            phrase_name_field->box(FL_ROUNDED_BOX);
            phrase_name_field->color(FL_BACKGROUND_COLOR);
            phrase_name_field->selection_color(FL_SELECTION_COLOR);
            phrase_name_field->labeltype(FL_NORMAL_LABEL);
            phrase_name_field->labelfont(2);
            phrase_name_field->labelsize(12);
            phrase_name_field->labelcolor((Fl_Color)55);
            phrase_name_field->textfont(2);
            phrase_name_field->textsize(12);
            phrase_name_field->callback((Fl_Callback*)cb_phrase_name_field);
            phrase_name_field->align(Fl_Align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE));
            phrase_name_field->when(FL_WHEN_RELEASE);
            o->up_box( FL_ROUNDED_BOX );
          } // Fl_Sometimes_Input* phrase_name_field
          { phrase_mute_button = new Fl_Light_Button(0, 751, 93, 23, "Mute");
            phrase_mute_button->color((Fl_Color)37);
            phrase_mute_button->hide();
          } // Fl_Light_Button* phrase_mute_button
          { phrase_solo_button = new Fl_Light_Button(106, 751, 87, 23, "Solo");
            phrase_solo_button->color((Fl_Color)37);
            phrase_solo_button->hide();
          } // Fl_Light_Button* phrase_solo_button
          { Fl_Text_Editor* o = phrase_notes_edit = new Fl_Text_Editor(200, 742, 660, 36, "Notes:");
            phrase_notes_edit->selection_color((Fl_Color)48);
            phrase_notes_edit->labelsize(12);
            phrase_notes_edit->textcolor((Fl_Color)94);
            phrase_notes_edit->callback((Fl_Callback*)cb_phrase_notes_edit);
            Fl_Group::current()->resizable(phrase_notes_edit);
            o->buffer( phrase_notes_buffer = new Fl_Text_Buffer );
          } // Fl_Text_Editor* phrase_notes_edit
          { phrase_number_spinner = new Fl_Value_Slider(45, 760, 140, 18, "Phrase:");
            phrase_number_spinner->type(1);
            phrase_number_spinner->labelsize(10);
            phrase_number_spinner->minimum(1);
            phrase_number_spinner->maximum(128);
            phrase_number_spinner->step(1);
            phrase_number_spinner->value(1);
            phrase_number_spinner->textsize(14);
            phrase_number_spinner->callback((Fl_Callback*)cb_phrase_number_spinner);
            phrase_number_spinner->align(Fl_Align(FL_ALIGN_LEFT));
          } // Fl_Value_Slider* phrase_number_spinner
          phrase_settings_group->end();
        } // Fl_Group* phrase_settings_group
        update_phrase_widgets();
        phrase_tab->end();
      } // Fl_Group* phrase_tab
      { pattern_tab = new Fl_Group(0, 91, 867, 694);
        pattern_tab->box(FL_FLAT_BOX);
        pattern_tab->color(FL_DARK1);
        pattern_tab->labeltype(FL_NO_LABEL);
        { pattern_canvas_widget = new Canvas(0, 91, 865, 637, "Pattern");
          pattern_canvas_widget->box(FL_FLAT_BOX);
          pattern_canvas_widget->color((Fl_Color)37);
          pattern_canvas_widget->selection_color(FL_BACKGROUND_COLOR);
          pattern_canvas_widget->labeltype(FL_NORMAL_LABEL);
          pattern_canvas_widget->labelfont(0);
          pattern_canvas_widget->labelsize(100);
          pattern_canvas_widget->labelcolor(FL_FOREGROUND_COLOR);
          pattern_canvas_widget->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
          pattern_canvas_widget->when(FL_WHEN_RELEASE);
          Fl_Group::current()->resizable(pattern_canvas_widget);
        } // Canvas* pattern_canvas_widget
        { pattern_settings_group = new Fl_Group(0, 730, 867, 55);
          pattern_settings_group->box(FL_FLAT_BOX);
          pattern_settings_group->color(FL_DARK1);
          { Fl_Group* o = new Fl_Group(5, 733, 420, 44);
            { Fl_Sometimes_Input* o = pattern_name_field = new Fl_Sometimes_Input(5, 734, 185, 21, "name:");
              pattern_name_field->box(FL_BORDER_BOX);
              pattern_name_field->color(FL_BACKGROUND_COLOR);
              pattern_name_field->selection_color(FL_SELECTION_COLOR);
              pattern_name_field->labeltype(FL_NORMAL_LABEL);
              pattern_name_field->labelfont(0);
              pattern_name_field->labelsize(12);
              pattern_name_field->labelcolor(FL_FOREGROUND_COLOR);
              pattern_name_field->textsize(12);
              pattern_name_field->textcolor((Fl_Color)55);
              pattern_name_field->callback((Fl_Callback*)cb_pattern_name_field);
              pattern_name_field->align(Fl_Align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE));
              pattern_name_field->when(FL_WHEN_ENTER_KEY);
              o->up_box( FL_BORDER_BOX );
            } // Fl_Sometimes_Input* pattern_name_field
            { pattern_mute_button = new Fl_Light_Button(195, 734, 58, 19, "Mute");
              pattern_mute_button->type(0);
              pattern_mute_button->shortcut(0x6d);
              pattern_mute_button->color((Fl_Color)37);
              pattern_mute_button->labelsize(12);
              pattern_mute_button->callback((Fl_Callback*)cb_pattern_mute_button);
            } // Fl_Light_Button* pattern_mute_button
            { pattern_solo_button = new Fl_Light_Button(195, 758, 58, 19, "Solo");
              pattern_solo_button->type(0);
              pattern_solo_button->shortcut(0x73);
              pattern_solo_button->color((Fl_Color)37);
              pattern_solo_button->labelsize(12);
              pattern_solo_button->callback((Fl_Callback*)cb_pattern_solo_button);
            } // Fl_Light_Button* pattern_solo_button
            { pattern_number_spinner = new Fl_Value_Slider(45, 759, 140, 18, "Pattern");
              pattern_number_spinner->type(1);
              pattern_number_spinner->labelsize(10);
              pattern_number_spinner->minimum(1);
              pattern_number_spinner->maximum(128);
              pattern_number_spinner->step(1);
              pattern_number_spinner->value(1);
              pattern_number_spinner->callback((Fl_Callback*)cb_pattern_number_spinner);
              pattern_number_spinner->align(Fl_Align(FL_ALIGN_LEFT));
            } // Fl_Value_Slider* pattern_number_spinner
            { pattern_selection_mode = new Fl_Button(260, 733, 45, 44, "Select");
              pattern_selection_mode->tooltip("Enable selection mode (you can also just hold down shift and drag the mouse)");
              pattern_selection_mode->type(1);
              pattern_selection_mode->selection_color((Fl_Color)5);
              pattern_selection_mode->labelsize(10);
              pattern_selection_mode->callback((Fl_Callback*)cb_pattern_selection_mode);
            } // Fl_Button* pattern_selection_mode
            { velocity_slider = new Fl_Value_Slider(310, 742, 110, 18, "Velocity");
              velocity_slider->type(3);
              velocity_slider->labelsize(10);
              velocity_slider->maximum(127);
              velocity_slider->value(64);
              velocity_slider->textsize(9);
              velocity_slider->callback((Fl_Callback*)cb_velocity_slider);
              velocity_slider->align(Fl_Align(FL_ALIGN_TOP));
            } // Fl_Value_Slider* velocity_slider
            o->resizable(0);
            o->end();
          } // Fl_Group* o
          { Fl_Group* o = new Fl_Group(455, 731, 409, 54);
            { mapping_text = new Fl_Output(535, 761, 105, 19, "Mapping");
              mapping_text->labelsize(10);
              mapping_text->textsize(11);
              mapping_text->align(Fl_Align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE));
            } // Fl_Output* mapping_text
            { mapping_menu = new Fl_Menu_Button(640, 761, 30, 19, "@>");
              mapping_menu->labeltype(FL_NO_LABEL);
              mapping_menu->labelsize(10);
              mapping_menu->textsize(12);
              mapping_menu->callback((Fl_Callback*)cb_mapping_menu);
              mapping_menu->menu(menu_mapping_menu);
              update_mapping_menu();
            } // Fl_Menu_Button* mapping_menu
            { pattern_key_combo = new Fl_Choice(700, 761, 75, 19, "&Key");
              pattern_key_combo->down_box(FL_BORDER_BOX);
              pattern_key_combo->labelsize(10);
              pattern_key_combo->textsize(11);
              pattern_key_combo->callback((Fl_Callback*)cb_pattern_key_combo);
              pattern_key_combo->when(FL_WHEN_CHANGED);
              pattern_key_combo->menu(menu_pattern_key_combo);
            } // Fl_Choice* pattern_key_combo
            { pattern_note_combo = new Fl_Choice(715, 736, 45, 19, "&Note 1/");
              pattern_note_combo->down_box(FL_BORDER_BOX);
              pattern_note_combo->labelsize(10);
              pattern_note_combo->textsize(12);
              pattern_note_combo->callback((Fl_Callback*)cb_pattern_note_combo);
              pattern_note_combo->when(FL_WHEN_CHANGED);
              pattern_note_combo->menu(menu_pattern_note_combo);
            } // Fl_Choice* pattern_note_combo
            { pattern_res_combo = new Fl_Choice(615, 736, 55, 19, "&Resolution 1/");
              pattern_res_combo->down_box(FL_BORDER_BOX);
              pattern_res_combo->labelsize(10);
              pattern_res_combo->textsize(12);
              pattern_res_combo->callback((Fl_Callback*)cb_pattern_res_combo);
              pattern_res_combo->when(FL_WHEN_CHANGED);
              pattern_res_combo->menu(menu_pattern_res_combo);
            } // Fl_Choice* pattern_res_combo
            { Fl_Choice* o = pattern_channel_choice = new Fl_Choice(810, 735, 47, 19, "Channel:");
              pattern_channel_choice->down_box(FL_BORDER_BOX);
              pattern_channel_choice->labelsize(10);
              pattern_channel_choice->textsize(12);
              pattern_channel_choice->callback((Fl_Callback*)cb_pattern_channel_choice);
              char pat[3]; for ( int i = 1; i <= 16; i++ ) { snprintf( pat, 3, "%i", i ); o->add( pat ); }
            } // Fl_Choice* pattern_channel_choice
            { Fl_Choice* o = pattern_port_choice = new Fl_Choice(810, 760, 47, 19, "Port:");
              pattern_port_choice->down_box(FL_BORDER_BOX);
              pattern_port_choice->labelsize(10);
              pattern_port_choice->textsize(12);
              pattern_port_choice->callback((Fl_Callback*)cb_pattern_port_choice);
              char pat[3]; for ( int i = 1; i <= 16; i++ ) { snprintf( pat, 3, "%i", i ); o->add( pat ); }
            } // Fl_Choice* pattern_port_choice
            { Fl_Input_Choice* o = pattern_bars_choice = new Fl_Input_Choice(486, 736, 55, 19, "Bars:");
              pattern_bars_choice->labelsize(10);
              pattern_bars_choice->textsize(12);
              pattern_bars_choice->callback((Fl_Callback*)cb_pattern_bars_choice);
              char pat[4]; for ( int i = 1; i <= 16; i++ ) { snprintf( pat, 3, "%i", i ); o->add( pat ); }
              for ( int i = 32; i <= 256; i <<= 1 ) { snprintf( pat, sizeof(pat), "%i", i ); o->add( pat ); }
            } // Fl_Input_Choice* pattern_bars_choice
            { Fl_Box* o = new Fl_Box(455, 735, 0, 46);
              o->labelsize(8);
              o->align(Fl_Align(FL_ALIGN_TOP));
              Fl_Group::current()->resizable(o);
            } // Fl_Box* o
            o->end();
          } // Fl_Group* o
          pattern_settings_group->end();
        } // Fl_Group* pattern_settings_group
        update_pattern_widgets();
        pattern_tab->end();
      } // Fl_Group* pattern_tab
      canvas_background_color = fl_rgb_color( 18, 18, 18 );
      tabs->end();
      Fl_Group::current()->resizable(tabs);
    } // Fl_Tabs* tabs
    { Fl_Group* o = new Fl_Group(0, 784, 865, 23);
      { Fl_Box* o = status = new Fl_Box(1, 784, 782, 23, "status");
        status->box(FL_UP_BOX);
        status->align(Fl_Align(68|FL_ALIGN_INSIDE));
        o->label( NULL );
      } // Fl_Box* status
      { transport_state = new Fl_Box(783, 784, 82, 23, "state");
        transport_state->box(FL_THIN_UP_BOX);
        transport_state->callback((Fl_Callback*)cb_transport_state);
        transport_state->align(Fl_Align(FL_ALIGN_CLIP));
      } // Fl_Box* transport_state
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(0, 0, 865, 24);
      { menu_bar = new Fl_Menu_Bar(0, 0, 865, 24);
        menu_bar->color(FL_DARK1);
        Fl_Group::current()->resizable(menu_bar);
        { Fl_Menu_Item* o = &menu_menu_bar[3];
          song.signal_dirty.connect( sigc::mem_fun( o, &Fl_Menu_Item::activate ) );
          song.signal_clean.connect( sigc::mem_fun( o, &Fl_Menu_Item::deactivate ) );
        }
        menu_bar->menu(menu_menu_bar);
      } // Fl_Menu_Bar* menu_bar
      { sm_indicator = new Fl_Button(825, 5, 35, 15, "SM");
        sm_indicator->box(FL_ROUNDED_BOX);
        sm_indicator->down_box(FL_ROUNDED_BOX);
        sm_indicator->color((Fl_Color)46);
        sm_indicator->selection_color((Fl_Color)93);
        sm_indicator->labelfont(3);
        sm_indicator->labelcolor(FL_DARK3);
        sm_indicator->deactivate();
      } // Fl_Button* sm_indicator
      o->end();
    } // Fl_Group* o
    o->color( FL_BACKGROUND_COLOR );
    o->draw_overlay_callback( &UI::draw_overlay, this );
    o->xclass( APP_NAME );
    main_window->size_range(700, 509);
    main_window->end();
  } // Overlay_Callback_Window* main_window
  return main_window;
}

Fl_Double_Window* UI::make_seq_window() {
  { seq_window = new Fl_Double_Window(876, 675, "Non Sequencer - Sequence");
    seq_window->callback((Fl_Callback*)cb_seq_window, (void*)(this));
    { seq_detached_group = new Fl_Group(0, 0, 876, 675);
      seq_detached_group->end();
      Fl_Group::current()->resizable(seq_detached_group);
    } // Fl_Group* seq_detached_group
    seq_window->end();
  } // Fl_Double_Window* seq_window
  return seq_window;
}

void UI::update_pattern_widgets() {
  if ( ! pattern_settings_group )
  	return;
  
  if ( !pattern_canvas_widget)
  	return;
  		
  pattern *g = (pattern *)pattern_canvas_widget->grid();
  
  if ( !g )
  	return;
  
  pattern_number_spinner->value( g->number() );
  pattern_name_field->value( g->name() );
  pattern_channel_choice->value( g->channel() );
  pattern_port_choice->value( g->port() );
  pattern_solo_button->value( g->mode() == SOLO );
  pattern_mute_button->value( g->mode() == MUTE );
  pattern_selection_mode->value( pattern_canvas_widget->selection_mode() );
  {
          char pat[5];
          snprintf( pat, sizeof(pat), "%i", g->bars() );
          pattern_bars_choice->value( pat );
  }
  
  if ( g->mapping.key() == -1 )
  	pattern_key_combo->deactivate();
  else
  {
  	pattern_key_combo->activate();
  	pattern_key_combo->value( g->mapping.key() );
  }
  
  mapping_text->value( g->mapping.name() );
  
  
  
  pattern_note_combo->value( find_numeric_menu_item( menu_pattern_note_combo, g->note() ));
  pattern_res_combo->value( find_numeric_menu_item( menu_pattern_res_combo, g->resolution() ));
  /*
  if ( g->notes() )
  	pattern_notes_buffer->text( g->notes() );
  else
  	pattern_notes_buffer->text( strdup( "" ) );
  */
  pattern_settings_group->redraw();
}

void UI::update_phrase_widgets() {
  if ( ! phrase_canvas_widget )
  	return;
  	
  phrase *g = (phrase *)phrase_canvas_widget->grid();
  
  if ( ! g )
  	return;
  	
  g->viewport.y = 0;
  g->viewport.h = pattern::patterns();
  phrase_canvas_widget->resize_grid();
  phrase_canvas_widget->changed_mapping();
  phrase_number_spinner->value( g->number() );
  phrase_name_field->value( g->name() );
  phrase_solo_button->value( g->mode() == SOLO );
  phrase_mute_button->value( g->mode() == MUTE );
  
  if ( g->notes() )
  	phrase_notes_buffer->text( g->notes() );
  else
  	phrase_notes_buffer->text( strdup( "" ) );
  
  phrase_settings_group->redraw();
}

void UI::update_sequence_widgets() {
  if ( playlist->notes() )
  	sequence_notes_buffer->text( playlist->notes() );
  else
  	sequence_notes_buffer->text( strdup( "" ) );
  	
  sequence_name_field->value( playlist->name() );
  
  sequence_phrase_choice->clear();
  
  for ( int i = 1; i <= phrase::phrases(); i++ )
  {
  	phrase *p = phrase::phrase_by_number( i );
  
  	if ( p )
  		sequence_phrase_choice->add( p->name() );
  }
  
  
  Fl_Browser *o = playlist_browser;
  
  int val = o->value();
  
  o->clear();
  
  char *s = playlist->dump();
  
  char *l = strtok( s, "\n" );
  
  o->add( "@b@C2Bar\t@b@C2#\t@b@C2Name" );
  
  if ( ! l )
  	return;
  
  o->add( l );
  
  while ( ( l = strtok( NULL, "\n" ) ) )
  {
  	o->add( l );
  }
  
  o->value( val );
  
  free( s );
  
  
  if ( playback_mode_menu )
  	playback_mode_menu->value( song.play_mode );
}

void UI::update_mapping_menu() {
  char **sa = Instrument::listing();
  
  if ( sa )
  {
  
  	for ( int i = 0; sa[i]; i++ )
  	{
  		char pat[512];
  		snprintf( pat, 512, "Instrument/%s", sa[i] );
  		mapping_menu->add( pat, 0, 0, 0, 0 );
  		free( sa[i] );
  	}
  	free( sa );
  }
  
  sa = Scale::listing();
  for ( int i = 0; sa[i]; i++ )
  {
  	char pat[512];
  	snprintf( pat, 512, "Scale/%s", sa[i] );
  	mapping_menu->add( pat, 0, 0, 0, 0 );
  	free( sa[i] );
  }
  free( sa );
}

void UI::update_canvas_widgets() {
  if ( ui->pattern_canvas_widget->grid() )
  	ui->update_pattern_widgets();
  
          if ( ui->phrase_canvas_widget->grid() )
  	ui->update_phrase_widgets();
}

int UI::find_numeric_menu_item( const Fl_Menu_Item *menu, int n ) {
  for ( unsigned int i = 0; menu[i].text; i++ )
  {
  	if ( atoi( menu[i].text ) == n )
  		return i;
  }
  
  return 0;
}

void UI::save_dialog( const char *name ) {
  if ( ! name )
  {
  
  	Fl_File_Chooser *fc = new Fl_File_Chooser( ".", "Non Sequences (*.non)", Fl_File_Chooser::CREATE, "Save sequence" );
  
  	fc->show();
  
  	// wait for user to make a choice
  	while( fc->shown() )
       		 Fl::wait();
  
  	if ( ! fc->value() )
  		return;
  	
  	name = fc->value();	
  }
  
  if ( ! save_song( name ) )
  	fl_alert( "Could not save song" );
  else
  	gui_status( "Saved." );
}

void UI::show_help_dialog( const char *file ) {
  char pat[256];
  
  snprintf( pat, 256, "file://%s/non-sequencer/%s.html", DOCUMENT_PATH, file );
  
  open_url( pat );
}

bool UI::maybe_save_song() {
  if ( song.dirty() )
  {
  	int c = fl_choice( "Song has been modified since last save. What shall I do?", "&Cancel", "&Save", "&Discard" );
  
  	switch ( c )
  	{
  		case 0:
  			return false;
  		case 1:
  			/* SAVE */
  			save_dialog( song.filename );
  			break;
  		case 2:
  			break;
  	}	
  }
  
  return true;
}

void UI::switch_to_pattern( int n ) {
  pattern *p = pattern::pattern_by_number( n );
  
  if ( p )
  {
  
  
  	
  	tabs->value( pattern_tab );
  	
  	pattern_canvas_widget->take_focus();
  	
  	pattern_canvas_widget->grid( p );
  	
  //	update_pattern_widgets();
  }
}

void UI::edit_instrument_row( Instrument *i, int n ) {
  Instrument_Editor ie;
  
  ie.set( i, n );
  
  ie.run();
}

Canvas* UI::current_canvas() {
  if ( tabs->value() == pattern_tab )
  	return pattern_canvas_widget;
  else if ( tabs->value() == phrase_tab )
  	return phrase_canvas_widget;
  else
  	return NULL;
}

void Instrument_Editor::cb_window_i(Fl_Double_Window*, void*) {
  done->do_callback();
}
void Instrument_Editor::cb_window(Fl_Double_Window* o, void* v) {
  ((Instrument_Editor*)(o->user_data()))->cb_window_i(o,v);
}

void Instrument_Editor::cb_name_field_i(Fl_Input* o, void*) {
  _inst->note_name( _note, strdup( o->value() ) );
}
void Instrument_Editor::cb_name_field(Fl_Input* o, void* v) {
  ((Instrument_Editor*)(o->parent()->user_data()))->cb_name_field_i(o,v);
}

void Instrument_Editor::cb_volume_slider_i(Fl_Value_Slider* o, void*) {
  _inst->velocity( _note, o->value() );
}
void Instrument_Editor::cb_volume_slider(Fl_Value_Slider* o, void* v) {
  ((Instrument_Editor*)(o->parent()->user_data()))->cb_volume_slider_i(o,v);
}

void Instrument_Editor::cb_done_i(Fl_Return_Button*, void*) {
  if ( _inst )
	_inst->save();
	
window->hide();
}
void Instrument_Editor::cb_done(Fl_Return_Button* o, void* v) {
  ((Instrument_Editor*)(o->parent()->user_data()))->cb_done_i(o,v);
}

Instrument_Editor::Instrument_Editor() {
  make_window();
}

Fl_Double_Window* Instrument_Editor::make_window() {
  { window = new Fl_Double_Window(335, 190, "Instrument Editor");
    window->callback((Fl_Callback*)cb_window, (void*)(this));
    { Fl_Box* o = new Fl_Box(8, 15, 321, 28, "Instrument Row");
      o->box(FL_ROUNDED_BOX);
      o->color((Fl_Color)94);
      o->labelsize(22);
      o->labelcolor(FL_DARK3);
    } // Fl_Box* o
    { name_field = new Fl_Input(10, 70, 321, 25, "Name");
      name_field->selection_color((Fl_Color)48);
      name_field->textcolor(FL_GRAY0);
      name_field->callback((Fl_Callback*)cb_name_field);
      name_field->align(Fl_Align(FL_ALIGN_TOP));
      name_field->when(FL_WHEN_CHANGED);
    } // Fl_Input* name_field
    { volume_slider = new Fl_Value_Slider(10, 112, 321, 27, "Volume %");
      volume_slider->type(1);
      volume_slider->maximum(100);
      volume_slider->step(1);
      volume_slider->textsize(14);
      volume_slider->callback((Fl_Callback*)cb_volume_slider);
      volume_slider->align(Fl_Align(FL_ALIGN_TOP));
    } // Fl_Value_Slider* volume_slider
    { note_field = new Fl_Value_Output(52, 158, 43, 24, "Note:");
    } // Fl_Value_Output* note_field
    { done = new Fl_Return_Button(255, 157, 76, 25, "Done");
      done->callback((Fl_Callback*)cb_done);
    } // Fl_Return_Button* done
    window->end();
  } // Fl_Double_Window* window
  return window;
}

void Instrument_Editor::set( Instrument *i, int n ) {
  _inst = i;
  _note = n;
  
  volume_slider->value( i->velocity( n ) );
  name_field->value( i->note_name( n ) );
  note_field->value( n );
}

void Instrument_Editor::run() {
  window->show();
  
  while ( window->shown() )
  	Fl::wait();
}

Trigger::Trigger( int X, int Y, int W, int H, const char *L ) : Fl_Progress( X, Y, W, H, L ) {
  minimum( 0 );
  maximum( 1 );
  //angles( 0, 360 );
  // type( Fl_Dial::ARC_DIAL );
  // type(FL_VERTICAL);
}

int Trigger::handle( int m ) {
  int r = 0;
  
  switch ( m )
  {
  	case FL_PUSH:
  	{
  		switch ( Fl::event_button() )
  		{
  			case 1:
  			{
   		      		pattern *p = pattern::pattern_by_number( atoi( label() ) );
  		
  				if ( p )
  				{                                  
                                       if ( TRIGGER == song.play_mode ) 		
                                       {
  					if ( p->playing() )
                                              p->stop();
  					else
                                              p->trigger();
                                       }
                                       else
                                       {
                                          if ( p->mode() == PLAY )
                                              p->mode( MUTE );
                                          else
                                              p->mode( PLAY );
                                       }
  				}
  				
  				break;
  			}
  			case 2:
  			{
   				pattern *p = pattern::pattern_by_number( atoi( label() ) );
  				
  				if ( p )
  				{
  					if ( p->mode() != SOLO )
  						p->mode( SOLO );
  					else
  						p->mode( PLAY );
  				}
  				
  				break;
  			}
  			case 3:
  			{
  				ui->switch_to_pattern( atoi( label() ) );
  			}
  				break;
  		}
  		r = 1;
  		break;
  	}
  	case FL_RELEASE:
  		do_callback();
  		r = 1;
  		break;
  	case FL_DRAG:
  		r = 1;
  		break;
  	default:
  		r = Fl_Widget::handle( m );
  		break;
  }
  
  
  return r;
}
Triggers::Triggers(int X, int Y, int W, int H, const char *L)
  : Fl_Group(X, Y, W, H, L) {
this->box(FL_FLAT_BOX);
this->color(FL_BACKGROUND_COLOR);
this->selection_color(FL_BACKGROUND_COLOR);
this->labeltype(FL_NO_LABEL);
this->labelfont(0);
this->labelsize(14);
this->labelcolor(FL_FOREGROUND_COLOR);
this->align(Fl_Align(FL_ALIGN_TOP));
this->when(FL_WHEN_RELEASE);
#include <stdlib.h>
populate();
end();
}

void Triggers::populate( void ) {
  _timer = 0;
  
           for ( int i = 0; i < 128; i++ )
               {
  		Trigger *b = new Trigger( 1,1,1,1 );
  			
  		char pat[4];
  		
  		sprintf( pat, "%d",i +1);		
  		b->label( strdup( pat ) );
  		b->labelsize( 8 );
  	        b->color2( FL_GRAY );
  		b->box( FL_FLAT_BOX );
  //		b->down_box( FL_ROUNDED_BOX );
  		b->selection_color( FL_GREEN );
  		b->color( FL_BLACK );
  		b->color2( FL_GREEN );
  		b->align( FL_ALIGN_CENTER );
  
                  add( b );
  	}
}

void Triggers::update( void ) {
  ++_timer;
  
      if ( !visible_r() )
          return;           
  
  if ( ! takesevents() )
  	return;
  
          Fl_Color mode_color[3];
  
          mode_color[PLAY] = fl_color_average( FL_GRAY, FL_GREEN, 0.5 );
  //        mode_color[PLAY] = fl_color;    
          mode_color[MUTE] = FL_LIGHT2;
          mode_color[SOLO] = fl_color_average( FL_GRAY, FL_RED, 0.5 );
  
  if ( ! _rows )
  	return;
  	
  for ( int i = 0; i < MAX_PATTERN; i++ )
  {
  	Trigger *b = (Trigger*)child( i );
  	
  	if ( i >= pattern::patterns() )
  	{
  		b->color( FL_BLACK );
  		b->value( 0 );
  		continue;
  	}
  	
  	pattern *p = pattern::pattern_by_number( i + 1 );
  			
  	if ( p->playing() )
  	{
  		b->color( FL_GRAY );
  		
  		b->selection_color( mode_color[ p->mode() ] );
  
                  if ( p->queue() >= 0 )
                  {
                        if ( _timer % 16 < 8 )
                        {
                              b->color( mode_color[ p->queue() ] );
                        }
                  }
  		
  		b->value( (double)p->index() / p->length() );
  	}
  	else
  	{
  		b->value( 0 );
  	}
  		
  }
}

void Triggers::rows(int v) {
  _rows = v;
  redraw();
}

void Triggers::draw() {
  int _cols = 128 / _rows;
  
  int bw = w() / _cols;
  int bh = h() / _rows;
  
  int t = 0;
  for ( int i = 0; i < _rows; i++ )
  	for ( int j = 0; j < _cols ; j++, t++ )
  		child( t )->resize( x() + (bw * j), y() + (bh * i), bw, bh );
  
  Fl_Group::draw();
}

void List_Chooser::cb_Cancel_i(Fl_Button*, void*) {
  browser->clear();
window->hide();
}
void List_Chooser::cb_Cancel(Fl_Button* o, void* v) {
  ((List_Chooser*)(o->parent()->parent()->user_data()))->cb_Cancel_i(o,v);
}

void List_Chooser::cb_button_i(Fl_Return_Button*, void*) {
  window->hide();
}
void List_Chooser::cb_button(Fl_Return_Button* o, void* v) {
  ((List_Chooser*)(o->parent()->parent()->user_data()))->cb_button_i(o,v);
}

List_Chooser::List_Chooser( const char *name, const char *action ) {
  { window = new Fl_Window(310, 545);
    window->user_data((void*)(this));
    { Fl_Browser* o = browser = new Fl_Browser(5, 26, 300, 480, "name");
      browser->type(3);
      browser->box(FL_THIN_DOWN_BOX);
      browser->color(FL_GRAY0);
      browser->selection_color(FL_FOREGROUND_COLOR);
      browser->textcolor((Fl_Color)55);
      browser->align(Fl_Align(FL_ALIGN_TOP));
      Fl_Group::current()->resizable(browser);
      o->label( name );
    } // Fl_Browser* browser
    { Fl_Group* o = new Fl_Group(5, 505, 300, 39);
      { Fl_Button* o = new Fl_Button(5, 513, 75, 27, "Cancel");
        o->callback((Fl_Callback*)cb_Cancel);
      } // Fl_Button* o
      { Fl_Return_Button* o = button = new Fl_Return_Button(115, 513, 190, 27, "action");
        button->callback((Fl_Callback*)cb_button);
        o->label( action );
      } // Fl_Return_Button* button
      o->end();
    } // Fl_Group* o
    window->set_non_modal();
    window->size_range(310, 524);
    window->end();
  } // Fl_Window* window
}

void List_Chooser::show() {
  window->show();
}

bool List_Chooser::shown() {
  return window->shown();
}

void List_Chooser::add( const char *item ) {
  browser->add( item );
}
static float status_intensity; 

static void fade_status(void*) {
  ui->status->labelcolor( fl_color_average( FL_FOREGROUND_COLOR, FL_BACKGROUND_COLOR, status_intensity ) );
  
      status_intensity -= 0.01f;
  
      ui->status->redraw();
  
      if ( status_intensity >= 0.01f )
          Fl::repeat_timeout( 1 / 15.0f, fade_status );
}

void gui_status( const char *fmt, ... ) {
  va_list args;
  
      static char pat[256];
  
      if ( fmt )
      {
          va_start( args, fmt );
          vsnprintf( pat, 256, fmt, args );
          va_end( args );
      }
  
      ui->status->label( pat );
      ui->status->redraw();
  
      status_intensity = 1.0f;
      Fl::remove_timeout( fade_status );
      Fl::add_timeout( 1 / 15.0f, fade_status );
}
