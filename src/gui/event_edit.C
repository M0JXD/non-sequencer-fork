//
// Copyright (C) 2008 Jonathan Moore Liles
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//

// generated by Fast Light User Interface Designer (fluid) version 1.0300

#include "event_edit.H"
#include "../grid.H"
#include "../scale.H"
using namespace MIDI;
extern Fl_Color velocity_colors[];

void Event_Editor::cb_window_i(Fl_Double_Window* o, void*) {
  delete _el;

_grid->events( _old );

delete _old;

_el = _old = NULL;

o->hide();

Fl::delete_widget( o );
}
void Event_Editor::cb_window(Fl_Double_Window* o, void* v) {
  ((Event_Editor*)(o->user_data()))->cb_window_i(o,v);
}

void Event_Editor::cb_Save_i(Fl_Return_Button*, void*) {
  delete window;
delete _el;
delete _old;
}
void Event_Editor::cb_Save(Fl_Return_Button* o, void* v) {
  ((Event_Editor*)(o->parent()->user_data()))->cb_Save_i(o,v);
}

void Event_Editor::cb_Discard_i(Fl_Button*, void*) {
  window->do_callback();
}
void Event_Editor::cb_Discard(Fl_Button* o, void* v) {
  ((Event_Editor*)(o->parent()->user_data()))->cb_Discard_i(o,v);
}

void Event_Editor::cb_Del_i(Fl_Button*, Event_Editor *) {
  _el->remove_selected();

sync();
}
void Event_Editor::cb_Del(Fl_Button* o, Event_Editor * v) {
  ((Event_Editor*)(o->parent()->user_data()))->cb_Del_i(o,v);
}

void Event_Editor::cb_Insert_i(Fl_Menu_Button* o, Event_Editor * v) {
  if ( o->value() == 0 )
{
	// note;
	
	event *on = new event;
	event *off = new event;
	
	on->status( event::NOTE_ON );
	on->note( 64 );
	on->note_velocity( 64 );
	
	off->status( event::NOTE_OFF );
	off->note( 64 );
	off->timestamp( 1 );
	off->note_velocity( 64 );
	
	on->link( off );
	
	_el->insert( on );
	_el->insert( off );

}
else
{
	event *e = new event;

	int opcode = e->name( o->menu()[ o->value() ].text );

	if ( opcode < 0 )
		return;
		
	e->status( opcode );

	Event_Widget *ew = v->value();

	if ( ew && ew->ev() )
		e->timestamp( ew->ev()->timestamp() );
	
	
	_el->insert( e );
}

sync();
}
void Event_Editor::cb_Insert(Fl_Menu_Button* o, Event_Editor * v) {
  ((Event_Editor*)(o->parent()->user_data()))->cb_Insert_i(o,v);
}

Fl_Menu_Item Event_Editor::menu_Insert[] = {
 {"Note", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Aftertouch", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Control Change", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Program Change", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Channel Pressure", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Pitch Wheel", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Double_Window* Event_Editor::make_window( Grid *g ) {
  { window = new Fl_Double_Window(655, 805, "Event Editor");
    window->callback((Fl_Callback*)cb_window, (void*)(this));
    { Fl_Scroll* o = new Fl_Scroll(10, 29, 635, 737, "Event List");
      o->type(6);
      o->box(FL_FLAT_BOX);
      { pack = new Fl_Pack(10, 29, 635, 737);
        pack->color(FL_DARK1);
        pack->when(FL_WHEN_RELEASE_ALWAYS);
        pack->end();
        Fl_Group::current()->resizable(pack);
      } // Fl_Pack* pack
      o->end();
    } // Fl_Scroll* o
    { Fl_Return_Button* o = new Fl_Return_Button(489, 771, 76, 25, "&Save");
      o->callback((Fl_Callback*)cb_Save);
    } // Fl_Return_Button* o
    { Fl_Button* o = new Fl_Button(575, 771, 74, 25, "&Discard");
      o->callback((Fl_Callback*)cb_Discard);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(10, 771, 74, 25, "Del");
      o->shortcut(0xffff);
      o->color(FL_RED);
      o->callback((Fl_Callback*)cb_Del, (void*)(this));
    } // Fl_Button* o
    { Fl_Menu_Button* o = new Fl_Menu_Button(94, 771, 121, 25, "&Insert");
      o->color(FL_GREEN);
      o->callback((Fl_Callback*)cb_Insert, (void*)(this));
      o->menu(menu_Insert);
    } // Fl_Menu_Button* o
    window->set_modal();
    window->size_range(0, 0, 659, 803);
    window->end();
    window->resizable(window);
  } // Fl_Double_Window* window
  // keep a copy
  _old = g->events();
  _el = g->events();
  
  _grid = g;
  _y = 0;
  
  _h = pack->h() / 24;
  
  update_widgets();
  return window;
}

void Event_Editor::sync( void ) {
  DMESSAGE( "syncing events to grid" );
  
  _grid->events( _el );
  
  update_widgets();
}

void Event_Editor::update_widgets( void ) {
  int i = 0;
  if ( ! _el->empty() )
  
  for ( event* e = (*_el)[0]; e; ( e = e->next() ), i++ )
  {
  	Event_Widget *ew;
  	
  	if ( i < pack->children() )
  	{
  		ew = (Event_Widget*)pack->child(i);
  	}
  	else
  	{
  		
  		ew = new Event_Widget( 0, 0, pack->w() - Fl::box_dw( pack->box() ), 24, 0 );
  	
  		ew->callback( cb_changed, (void*)this );
  		ew->when( FL_WHEN_CHANGED );
  		pack->add( ew );
  	}
  
  	ew->ev( e );
  }
  
  // pack->parent()->redraw();
}

Event_Widget * Event_Editor::value( void ) {
  for ( int i = 0; i < pack->children(); i++ )
  {
  	Event_Widget *w = (Event_Widget*)pack->child( i );
  	if ( w->selected() )
  		return w;
  }
  
  return NULL;
}

void Event_Editor::cb_changed( Fl_Widget *w, void *ee ) {
  Event_Widget *ew = (Event_Widget*)w;
  
  if ( ew->changed() )
  	// sorting order changed.
  	((Event_Editor*)ee)->_el->sort( ew->ev() );
  
  ((Event_Editor*)ee)->sync();
}

void event_editor( Grid *g ) {
  Event_Editor ee;
  
  
  Fl_Window *w = ee.make_window( g );
  
  w->modal();
  w->show();
  
  while( w->shown() )
  	Fl::wait();
}

void Event_Widget::cb_time_i(Fl_Value_Input* o, void*) {
  if ( _event->is_note_off() )
{
	if ( o->value() < _event->link()->timestamp() )
	{
		o->value( _event->timestamp() );
		return;
	}
}
else
if ( _event->is_note_on() )
	if ( o->value() > _event->link()->timestamp() )
	{
		o->value( _event->timestamp() );
		return;
	}
		
	
_event->timestamp( o->value() );

set_changed();
do_callback();
}
void Event_Widget::cb_time(Fl_Value_Input* o, void* v) {
  ((Event_Widget*)(o->parent()))->cb_time_i(o,v);
}

void Event_Widget::cb_name_i(Fl_Button* o, void*) {
  if ( o->value() )
	_event->select();
else
	_event->deselect();
	
do_callback();
}
void Event_Widget::cb_name(Fl_Button* o, void* v) {
  ((Event_Widget*)(o->parent()))->cb_name_i(o,v);
}

void Event_Widget::cb_Pitch_i(Fl_Slider* o, void *) {
  _event->pitch( o->value() );
do_callback();
}
void Event_Widget::cb_Pitch(Fl_Slider* o, void * v) {
  ((Event_Widget*)(o->parent()->parent()))->cb_Pitch_i(o,v);
}
Event_Widget::Event_Widget(int X, int Y, int W, int H, const char *L)
  : Fl_Group(X, Y, W, H, L) {
this->box(FL_FLAT_BOX);
this->color(FL_BACKGROUND_COLOR);
this->selection_color(FL_BACKGROUND_COLOR);
this->labeltype(FL_NO_LABEL);
this->labelfont(0);
this->labelsize(14);
this->labelcolor(FL_FOREGROUND_COLOR);
this->align(Fl_Align(FL_ALIGN_TOP));
this->when(FL_WHEN_RELEASE);
{ Fl_Value_Input* o = time = new Fl_Value_Input(3, 0, 125, 24);
  time->labeltype(FL_NO_LABEL);
  time->maximum(0);
  time->callback((Fl_Callback*)cb_time);
  time->align(Fl_Align(FL_ALIGN_CENTER));
  time->when(FL_WHEN_ENTER_KEY);
  o->maximum( (unsigned long)-1 );
} // Fl_Value_Input* time
{ name = new Fl_Button(132, -1, 149, 25, "<Event Name>");
  name->type(1);
  name->callback((Fl_Callback*)cb_name);
  name->when(FL_WHEN_CHANGED);
} // Fl_Button* name
{ note_tab = new Fl_Group(282, -3, 324, 37);
  note_tab->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
  { Fl_Value_Input* o = new Fl_Value_Input(359, 0, 51, 24, "Note:");
    o->maximum(127);
    o->step(1);
    o->callback((Fl_Callback*)cb_note, (void*)(this));
    o->when(FL_WHEN_RELEASE);
  } // Fl_Value_Input* o
  { Fl_Value_Slider* o = new Fl_Value_Slider(480, 0, 110, 24, "Velocity:");
    o->type(3);
    o->selection_color((Fl_Color)80);
    o->maximum(127);
    o->step(1);
    o->callback((Fl_Callback*)cb_msb, (void*)(this));
    o->align(Fl_Align(FL_ALIGN_LEFT));
    o->when(FL_WHEN_RELEASE);
  } // Fl_Value_Slider* o
  { note_name = new Fl_Box(284, 1, 31, 24, "A#");
    note_name->labeltype(FL_SHADOW_LABEL);
    note_name->labelfont(14);
    note_name->labelcolor((Fl_Color)135);
  } // Fl_Box* note_name
  note_tab->end();
} // Fl_Group* note_tab
{ after_tab = new Fl_Group(317, 0, 277, 25);
  after_tab->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
  after_tab->hide();
  { Fl_Value_Input* o = new Fl_Value_Input(359, 0, 51, 24, "Note:");
    o->maximum(127);
    o->step(1);
    o->callback((Fl_Callback*)cb_note, (void*)(this));
    o->when(FL_WHEN_RELEASE);
  } // Fl_Value_Input* o
  { Fl_Value_Slider* o = new Fl_Value_Slider(480, 0, 110, 24, "Pressure:");
    o->type(3);
    o->selection_color((Fl_Color)80);
    o->maximum(127);
    o->step(1);
    o->callback((Fl_Callback*)cb_msb, (void*)(this));
    o->align(Fl_Align(FL_ALIGN_LEFT));
    o->when(FL_WHEN_RELEASE);
  } // Fl_Value_Slider* o
  after_tab->end();
} // Fl_Group* after_tab
{ control_tab = new Fl_Group(358, 0, 238, 34);
  control_tab->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
  control_tab->hide();
  { Fl_Value_Input* o = new Fl_Value_Input(359, 0, 51, 24, "Control:");
    o->maximum(127);
    o->step(1);
    o->callback((Fl_Callback*)cb_lsb, (void*)(this));
    o->when(FL_WHEN_RELEASE);
  } // Fl_Value_Input* o
  { Fl_Value_Input* o = new Fl_Value_Input(480, 0, 51, 24, "Value:");
    o->maximum(127);
    o->step(1);
    o->callback((Fl_Callback*)cb_msb, (void*)(this));
    o->when(FL_WHEN_RELEASE);
  } // Fl_Value_Input* o
  control_tab->end();
} // Fl_Group* control_tab
{ prog_tab = new Fl_Group(287, 0, 238, 25);
  prog_tab->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
  prog_tab->hide();
  { Fl_Value_Input* o = new Fl_Value_Input(359, 0, 51, 24, "Program:");
    o->maximum(127);
    o->step(1);
    o->callback((Fl_Callback*)cb_lsb, (void*)(this));
    o->when(FL_WHEN_RELEASE);
  } // Fl_Value_Input* o
  prog_tab->end();
} // Fl_Group* prog_tab
{ pitch_tab = new Fl_Group(306, 0, 290, 24);
  pitch_tab->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
  pitch_tab->hide();
  { Fl_Slider* o = new Fl_Slider(358, 0, 231, 24, "Pitch:");
    o->type(1);
    o->minimum(-8192);
    o->maximum(8191);
    o->step(1);
    o->callback((Fl_Callback*)cb_Pitch);
    o->align(Fl_Align(FL_ALIGN_LEFT));
    o->when(FL_WHEN_RELEASE);
  } // Fl_Slider* o
  pitch_tab->end();
} // Fl_Group* pitch_tab
{ pressure_tab = new Fl_Group(307, 0, 291, 24);
  pressure_tab->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
  pressure_tab->hide();
  { Fl_Slider* o = new Fl_Slider(359, 0, 230, 24, "Pressure:");
    o->type(3);
    o->maximum(127);
    o->step(1);
    o->callback((Fl_Callback*)cb_lsb, (void*)(this));
    o->align(Fl_Align(FL_ALIGN_LEFT));
    o->when(FL_WHEN_RELEASE);
  } // Fl_Slider* o
  pressure_tab->end();
} // Fl_Group* pressure_tab
_event = NULL;
end();
}

void Event_Widget::ev( MIDI::event * e ) {
  if ( e && ( _event == NULL ) )
  	activate();
  else
  if ( ! e )
  {
  	_event = NULL;
  	deactivate();
  	return;
  }
  
  activate();
  
  _event = e;
  	
  name->label( e->name() );
  time->value( e->timestamp() );
  
  // hide all tabs
  for ( int i = 2; i < children(); i++ )
  	child( i )->hide();
  
  Fl_Valuator *d1, *d2;
  
  d1 = d2 = NULL;
  
  name->color( FL_BLACK );
  name->value( e->selected() );
  
  // display the proper subtype
  switch ( e->opcode() )
  {
  #define TWO d1 = (Fl_Valuator*)tab->child( 0 ); d2 = (Fl_Valuator*)tab->child( 1 )
  #define ONE d1 = (Fl_Valuator*)tab->child( 0 ); d2 = NULL
  		
  	case midievent::NOTE_ON:
  	case midievent::NOTE_OFF:
  		tab = note_tab;
  		name->color( note_color );
  		
  		note_name->label( Scale::chromatic_name( e->note() ) );
  		note_name->labelcolor( velocity_colors[ e->note_velocity() ] );
  		
  		TWO;
  		break;
  	case midievent::CONTROL_CHANGE:
  		tab = control_tab;
  		name->color( control_color );
  		
  		TWO;
  		break;
  	case midievent::AFTERTOUCH:
  		tab = after_tab;
  		name->color( after_color );
  		
  		TWO;
  		break;
  	case midievent::CHANNEL_PRESSURE:
  		tab = pressure_tab;
  		name->color( pressure_color );
  		
  		ONE;
  		break;
  	case midievent::PROGRAM_CHANGE:
  		tab = prog_tab;
  		name->color( prog_color );
  		
  		ONE;
  		break;
  	case midievent::PITCH_WHEEL:
  		tab = pitch_tab;
  		name->color( pitch_color );
  		
  		ONE;
  		d1->value( e->pitch() );
  		goto pitch;
  		break;
  }
  
  
  byte_t D1, D2;
  		
  e->data( &D1, &D2 );
  		
  d1->value( D1 );
  if ( d2 )
  	d2->value( D2 );
  	
  
  pitch:
  
  // show the current tab
  tab->show();
  
  time->redraw();
  name->redraw();
  
  // redraw();
}

MIDI::event * Event_Widget::ev( void ) {
  return _event;
}

void Event_Widget::select( bool b ) {
  /*
  _selected = b;
  
  if ( b )
  	name->color( FL_WHITE );
  	
  redraw();
  */
}

Fl_Button * Event_Widget::button() {
  return name;
}

bool Event_Widget::selected( void ) {
  /*
  int n = name->value();
  name->value( 0 );
  return n;
  */
  
  return name->value();
}

void Event_Widget::cb_lsb( Fl_Valuator *o, Event_Widget *w ) {
  w->ev()->lsb( o->value() );
  
  w->do_callback();
}

void Event_Widget::cb_msb( Fl_Valuator *o, Event_Widget *w ) {
  w->ev()->msb( o->value() );
  w->do_callback();
}

void Event_Widget::cb_note( Fl_Valuator *o, Event_Widget *w ) {
  w->ev()->note( o->value() );
  w->do_callback();
}
